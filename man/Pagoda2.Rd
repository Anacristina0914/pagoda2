% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Pagoda2.R
\name{Pagoda2}
\alias{Pagoda2}
\title{Pagoda2 R6 class}
\description{
The class encompasses gene count matrices, providing methods for normalization, calculating embeddings, and differential expression.
}
\examples{

## ------------------------------------------------
## Method `Pagoda2$new`
## ------------------------------------------------

cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, , min.cells.per.gene=10, n.cores=1) 


## ------------------------------------------------
## Method `Pagoda2$adjustVariance`
## ------------------------------------------------

cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)


## ------------------------------------------------
## Method `Pagoda2$makeKnnGraph`
## ------------------------------------------------

cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=300)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$makeKnnGraph(k=20, center=FALSE, distance='L2')


## ------------------------------------------------
## Method `Pagoda2$getKnnClusters`
## ------------------------------------------------

cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=900)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$makeKnnGraph(k=20, center=FALSE, distance='L2')
p2_object$getKnnClusters(method=infomap.community, type='counts')


## ------------------------------------------------
## Method `Pagoda2$getHierarchicalDiffExpressionAspects`
## ------------------------------------------------

cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=400)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=20, type='PCA', center=FALSE, distance='cosine')
p2_object$getKnnClusters(method=walktrap.community,type='PCA',name='walktrap')
p2_object$getEmbedding(type='PCA', embeddingType = 'largeVis', M=30, perplexity=30, gamma=1/30, alpha=1)
p2_object$getDifferentialGenes(type='PCA', verbose=TRUE, clusterType='walktrap')
hdea <- p2_object$getHierarchicalDiffExpressionAspects(type='PCA', clusterName='walktrap', z.threshold=3)


## ------------------------------------------------
## Method `Pagoda2$makeGeneKnnGraph`
## ------------------------------------------------

cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeGeneKnnGraph(nPcs=50, k=20, center=TRUE)


## ------------------------------------------------
## Method `Pagoda2$getDensityClusters`
## ------------------------------------------------

  
cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=50, type='PCA', center=TRUE, distance='cosine')
p2_object$getEmbedding(type='PCA', embeddingType = 'UMAP', M=20, perplexity=30, gamma=1/20)
p2_object$getDensityClusters(type='PCA')


## ------------------------------------------------
## Method `Pagoda2$getDifferentialGenes`
## ------------------------------------------------

cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=50, type='PCA', center=TRUE, distance='cosine')
p2_object$getKnnClusters(method=multilevel.community,type='PCA',name='multilevel')
p2_object$getEmbedding(type='PCA', embeddingType = 'UMAP', M=20, perplexity=30, gamma=1/20)
p2_object$getDifferentialGenes(type='PCA',verbose=TRUE,clusterType='multilevel')


## ------------------------------------------------
## Method `Pagoda2$plotGeneHeatmap`
## ------------------------------------------------

cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=50, type='PCA', center=TRUE, distance='cosine')
p2_object$getKnnClusters(method=multilevel.community,type='PCA',name='multilevel')
p2_object$getEmbedding(type='PCA', embeddingType = 'UMAP', M=20, perplexity=30, gamma=1/20)
p2_object$getDifferentialGenes(type='PCA',verbose=TRUE,clusterType='multilevel')
de <- p2_object$diffgenes$PCA[[1]][['2']]
p2_object$plotGeneHeatmap(genes=rownames(de)[1:15], groups=p2_object$clusters$PCA[[1]], cluster.genes=TRUE)


## ------------------------------------------------
## Method `Pagoda2$plotEmbedding`
## ------------------------------------------------

\dontrun{
cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=50, type='PCA', center=TRUE, distance='cosine')
p2_object$getKnnClusters(method=multilevel.community,type='PCA',name='multilevel')
p2_object$getEmbedding(type='PCA', embeddingType = 'UMAP', M=20, perplexity=30, gamma=1/20)
library(ggplot2)
p2_object$plotEmbedding(type='PCA', show.legend=FALSE, mark.groups=TRUE, min.cluster.size=50, shuffle.colors=FALSE, font.size=1, alpha=0.1, 
  title='clusters (UMAP)', plot.theme=theme(plot.title = element_text(hjust = 0.5)))
}


## ------------------------------------------------
## Method `Pagoda2$getOdGenes`
## ------------------------------------------------

cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=50, type='PCA', center=TRUE, distance='cosine')
p2_object$getKnnClusters(method=infomap.community, type='PCA')
p2_object$getEmbedding(type='PCA', M=20, perplexity=30, gamma=1/20)
p2_object$getDifferentialGenes(type='PCA',verbose=TRUE)
odGenes <- p2_object$getOdGenes(use.unadjusted.pvals=FALSE)


## ------------------------------------------------
## Method `Pagoda2$getNormalizedExpressionMatrix`
## ------------------------------------------------

cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$getNormalizedExpressionMatrix()


## ------------------------------------------------
## Method `Pagoda2$calculatePcaReduction`
## ------------------------------------------------

cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=600)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts, log.scale=FALSE, min.cells.per.gene=30, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=15)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=2e3)


## ------------------------------------------------
## Method `Pagoda2$expandOdGenes`
## ------------------------------------------------

cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=50, type='PCA', center=TRUE, distance='cosine')
p2_object$getKnnClusters(method=infomap.community, type='PCA')
p2_object$getEmbedding(type='PCA', M=20, perplexity=30, gamma=1/20)
p2_object$getDifferentialGenes(type='PCA',verbose=TRUE)
p2_object$expandOdGenes(type='PCA')


## ------------------------------------------------
## Method `Pagoda2$getEmbedding`
## ------------------------------------------------

cm <- readRDS(file.path(find.package('pagoda2'),'extdata','sample_BM1.rds'))
counts <- gene.vs.molecule.cell.filter(cm,min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=40, type='PCA', center=TRUE, distance='cosine')
p2_object$getKnnClusters(method=infomap.community, type='PCA')
p2_object$getEmbedding(type='PCA', embeddingType = 'UMAP', M=30, perplexity=30, gamma=1/30, alpha=1)

}
\author{
Simon Steiger
}
\keyword{internal}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{counts}}{Gene count matrix, normalized on total counts (default=NULL)}

\item{\code{modelType}}{string Model used to normalize count matrices. Only supported values are 'raw', 'plain', and 'linearObs'.
-- 'plain': Normalize by regressing out on the non-zero observations of each gene (default).
-- 'raw': Use the raw count matrices, without normalization. The expression matrix taken "as is" without normalization, although log.scale still applies. 
-- 'linearObs': Fit a linear model of pooled counts across all genes against depth. This approach isn't recommened, as the depth dependency is not completely normalized out.}

\item{\code{clusters}}{Results of clustering (default=list())}

\item{\code{graphs}}{Graph representations of the dataset (default=list())}

\item{\code{reductions}}{Results of reductions, e.g. PCA (default=list())}

\item{\code{embeddings}}{Results of visualization algorithms, t-SNE or largeVis (default=list())}

\item{\code{diffgenes}}{Lists of differentially expressed genes (default=list())}

\item{\code{n.cores}}{number of cores (default=1)}

\item{\code{misc}}{list with additional info (default=list())}

\item{\code{batch}}{Batch factor for the dataset (default=NULL)}

\item{\code{genegraphs}}{Slot to store graphical representations in gene space (i.e. gene kNN graphs) (default=list())}

\item{\code{depth}}{Number of molecules measured per cell (default=NULL)}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{Pagoda2$new()}}
\item \href{#method-setCountMatrix}{\code{Pagoda2$setCountMatrix()}}
\item \href{#method-adjustVariance}{\code{Pagoda2$adjustVariance()}}
\item \href{#method-makeKnnGraph}{\code{Pagoda2$makeKnnGraph()}}
\item \href{#method-getKnnClusters}{\code{Pagoda2$getKnnClusters()}}
\item \href{#method-geneKnnbyPCA}{\code{Pagoda2$geneKnnbyPCA()}}
\item \href{#method-getHierarchicalDiffExpressionAspects}{\code{Pagoda2$getHierarchicalDiffExpressionAspects()}}
\item \href{#method-makeGeneKnnGraph}{\code{Pagoda2$makeGeneKnnGraph()}}
\item \href{#method-getDensityClusters}{\code{Pagoda2$getDensityClusters()}}
\item \href{#method-getDifferentialGenes}{\code{Pagoda2$getDifferentialGenes()}}
\item \href{#method-plotDiffGeneHeatmap}{\code{Pagoda2$plotDiffGeneHeatmap()}}
\item \href{#method-getRefinedLibSizes}{\code{Pagoda2$getRefinedLibSizes()}}
\item \href{#method-plotGeneHeatmap}{\code{Pagoda2$plotGeneHeatmap()}}
\item \href{#method-plotEmbedding}{\code{Pagoda2$plotEmbedding()}}
\item \href{#method-getOdGenes}{\code{Pagoda2$getOdGenes()}}
\item \href{#method-getNormalizedExpressionMatrix}{\code{Pagoda2$getNormalizedExpressionMatrix()}}
\item \href{#method-calculatePcaReduction}{\code{Pagoda2$calculatePcaReduction()}}
\item \href{#method-expandOdGenes}{\code{Pagoda2$expandOdGenes()}}
\item \href{#method-localPcaKnn}{\code{Pagoda2$localPcaKnn()}}
\item \href{#method-testPathwayOverdispersion}{\code{Pagoda2$testPathwayOverdispersion()}}
\item \href{#method-getEmbedding}{\code{Pagoda2$getEmbedding()}}
\item \href{#method-clone}{\code{Pagoda2$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Initialize Conos class
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$new(
  x,
  modelType = "plain",
  n.cores = parallel::detectCores(logical = FALSE),
  verbose = TRUE,
  min.cells.per.gene = 0,
  trim = round(min.cells.per.gene/2),
  min.transcripts.per.cell = 10,
  lib.sizes = NULL,
  log.scale = TRUE,
  keep.genes = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{input count matrix}

\item{\code{modelType}}{Model used to normalize count matrices (default='plain'). Only supported values are 'raw', 'plain', and 'linearObs'.}

\item{\code{n.cores}}{numeric Number of cores to use (default=1)}

\item{\code{verbose}}{boolean Whether to give verbose output (default=TRUE)}

\item{\code{min.cells.per.gene}}{integer Minimum number of cells per gene, used to subset counts for coverage (default=0)}

\item{\code{trim}}{numeric Parameter used for winsorizing count data (default=round(min.cells.per.gene/2)). If value>0, will winsorize counts in normalized space in the hopes of getting a more stable depth estimates. If value<=0, ignored.}

\item{\code{min.transcripts.per.cell}}{integer Minimum number of transcripts per cells, used to subset counts for coverage (default=10)}

\item{\code{lib.sizes}}{character vector of library sizes (default=NULL)}

\item{\code{log.scale}}{boolean If TRUE, scale counts by log() (default=TRUE)}

\item{\code{keep.genes}}{list of genes to keep in count matrix after filtering out by coverage but before normalization (default=NULL)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
new 'Pagoda2' object
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, , min.cells.per.gene=10, n.cores=1) 

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-setCountMatrix"></a>}}
\if{latex}{\out{\hypertarget{method-setCountMatrix}{}}}
\subsection{Method \code{setCountMatrix()}}{
Provide the initial count matrix, and estimate deviance residual matrix (correcting for depth and batch)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$setCountMatrix(
  countMatrix,
  depthScale = 1000,
  min.cells.per.gene = 0,
  trim = round(min.cells.per.gene/2),
  min.transcripts.per.cell = 10,
  lib.sizes = NULL,
  log.scale = FALSE,
  keep.genes = NULL,
  verbose = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{countMatrix}}{input count matrix}

\item{\code{depthScale}}{numeric Scaling factor for normalizing counts (defaul=1e3). If 'plain', counts are scaled by counts = counts/as.numeric(depth/depthScale).}

\item{\code{min.cells.per.gene}}{integer Minimum number of cells per gene, used to subset counts for coverage (default=0)}

\item{\code{trim}}{numeric Parameter used for winsorizing count data (default=round(min.cells.per.gene/2)). If value>0, will winsorize counts in normalized space in the hopes of getting a more stable depth estimates. If value<=0, ignored.}

\item{\code{min.transcripts.per.cell}}{integer Minimum number of transcripts per cells, used to subset counts for coverage (default=10)}

\item{\code{lib.sizes}}{character vector of library sizes (default=NULL)}

\item{\code{log.scale}}{boolean If TRUE, scale counts by log() (default=TRUE)}

\item{\code{keep.genes}}{list of genes to keep in count matrix after filtering out by coverage but before normalization (default=NULL)}

\item{\code{verbose}}{boolean Whether to give verbose output (default=TRUE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
normalized count matrix (or if modelTye='raw', the unnormalized count matrix)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-adjustVariance"></a>}}
\if{latex}{\out{\hypertarget{method-adjustVariance}{}}}
\subsection{Method \code{adjustVariance()}}{
Adjust variance of the residual matrix, determine overdispersed sites
This is done to normalize the extent to which genes with (very) different expression magnitudes will contribute to the downstream anlaysis.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$adjustVariance(
  gam.k = 5,
  alpha = 0.05,
  plot = FALSE,
  use.raw.variance = FALSE,
  use.unadjusted.pvals = FALSE,
  do.par = TRUE,
  max.adjusted.variance = 1000,
  min.adjusted.variance = 0.001,
  cells = NULL,
  verbose = TRUE,
  min.gene.cells = 0,
  persist = is.null(cells),
  n.cores = self$n.cores
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{gam.k}}{integer The k used for the generalized additive model 'v ~ s(m, k =gam.k)' (default=5). If gam.k<2, linear regression is used 'lm(v ~ m)'.}

\item{\code{alpha}}{numeric The Type I error probability or the significance level (default=5e-2). This is the criterion used to measure statistical significance, i.e. if the p-value < alpha, then it is statistically significant.}

\item{\code{plot}}{boolean Whether to output the plot (default=FALSE)}

\item{\code{use.raw.variance}}{(default=FALSE). If modelType='raw', then this conditional will be used as TRUE.}

\item{\code{use.unadjusted.pvals}}{boolean Whether to use Benjamini-Hochberg adjusted p-values (default=FALSE).}

\item{\code{do.par}}{boolean Whether to put multiple graphs into a signle plot with par() (default=TRUE)}

\item{\code{max.adjusted.variance}}{numeric Maximum adjusted variance (default=1e3). The gene scale factor is defined as sqrt(pmax(min.adjusted.variance,pmin(max.adjusted.variance,df$qv))/exp(df$v))}

\item{\code{min.adjusted.variance}}{numeric Minimum adjusted variance (default=1e-3). The gene scale factor is defined as sqrt(pmax(min.adjusted.variance,pmin(max.adjusted.variance,df$qv))/exp(df$v))}

\item{\code{cells}}{character vector Subset of cells upon which to perform variance normalization with adjustVariance() (default=NULL)}

\item{\code{verbose}}{boolean Whether to give verbose output (default=TRUE)}

\item{\code{min.gene.cells}}{integer Minimum number of genes per cells (default=0). This parameter is used to filter counts.}

\item{\code{persist}}{boolean Whether to save results (default=TRUE, i.e. is.null(cells)).}

\item{\code{n.cores}}{numeric Number of cores to use (default=1)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
residual matrix with adjusted variance
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-makeKnnGraph"></a>}}
\if{latex}{\out{\hypertarget{method-makeKnnGraph}{}}}
\subsection{Method \code{makeKnnGraph()}}{
Create k-nearest neighbor graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$makeKnnGraph(
  k = 30,
  nrand = 1000,
  type = "counts",
  weight.type = "1m",
  odgenes = NULL,
  n.cores = self$n.cores,
  distance = "cosine",
  center = TRUE,
  x = NULL,
  p = NULL,
  var.scale = (type == "counts"),
  verbose = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{k}}{integer Number of k clusters for k-NN (default=30)}

\item{\code{nrand}}{numeric (default=1e3)}

\item{\code{type}}{string Data type of the reduction (default='counts'). If type='counts', this will access the raw counts. Otherwise, 'type' must be name of the reductions.}

\item{\code{weight.type}}{string 'cauchy', 'normal', 'constant', '1m' (default='1m')}

\item{\code{odgenes}}{character vector Overdispersed genes to retrieve (default=NULL)}

\item{\code{n.cores}}{numeric Number of cores to use (default=1)}

\item{\code{distance}}{string Distance metric used: 'cosine', 'L2', 'L1', 'cauchy', 'euclidean' (default='cosine')}

\item{\code{center}}{boolean Whether to use centering when distance='cosine' (default=TRUE). The parameter is ignored otherwise.}

\item{\code{x}}{counts or reduction to use (default=NULL). If NULL, uses counts. Otherwise, checks for the reduction in self$reductions[[type]]}

\item{\code{p}}{(default=NULL)}

\item{\code{var.scale}}{boolean (default=TRUE)}

\item{\code{verbose}}{boolean Whether to give verbose output (default=TRUE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
k-NN graph
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=300)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$makeKnnGraph(k=20, center=FALSE, distance='L2')

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getKnnClusters"></a>}}
\if{latex}{\out{\hypertarget{method-getKnnClusters}{}}}
\subsection{Method \code{getKnnClusters()}}{
Calculate clusters based on the kNN graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$getKnnClusters(
  type = "counts",
  method = igraph::multilevel.community,
  name = "community",
  n.cores = self$n.cores,
  g = NULL,
  min.cluster.size = 1,
  persist = TRUE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{string Data type (default='counts'). Currently only 'counts' supported.}

\item{\code{method}}{Method to use (default=igraph::multilevel.community). Accepted methods are either 'igraph::infomap.community' or 'igraph::multilevel.community'. 
If NULL, if the number of vertices of the graph is greater than or equal to 2000, 'igraph::multilevel.community' will be used. Otherwise, 'igraph::infomap.community' will be used.}

\item{\code{name}}{string Name of the community structure calculated from 'method' (default='community')}

\item{\code{n.cores}}{numeric Number of cores to use (default=1)}

\item{\code{g}}{Input graph (default=NULL). If NULL, access graph from self$graphs[[type]].}

\item{\code{min.cluster.size}}{Minimum size of clusters (default=1). This parameter is primarily used to remove very small clusters.}

\item{\code{persist}}{boolean Whether to save the clusters and community structure (default=TRUE)}

\item{\code{...}}{additional parameters to pass to 'method'}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the community structure calculated from 'method'
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=900)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$makeKnnGraph(k=20, center=FALSE, distance='L2')
p2_object$getKnnClusters(method=infomap.community, type='counts')

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-geneKnnbyPCA"></a>}}
\if{latex}{\out{\hypertarget{method-geneKnnbyPCA}{}}}
\subsection{Method \code{geneKnnbyPCA()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$geneKnnbyPCA()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getHierarchicalDiffExpressionAspects"></a>}}
\if{latex}{\out{\hypertarget{method-getHierarchicalDiffExpressionAspects}{}}}
\subsection{Method \code{getHierarchicalDiffExpressionAspects()}}{
Take a given clustering and generate a hierarchical clustering
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$getHierarchicalDiffExpressionAspects(
  type = "counts",
  groups = NULL,
  clusterName = NULL,
  dist = "pearson",
  persist = TRUE,
  z.threshold = 2,
  n.cores = self$n.cores,
  min.set.size = 5,
  verbose = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{string Data type of the reduction (default='counts'). If type='counts', this will access the raw counts. Otherwise, 'type' must be name of the reductions.}

\item{\code{groups}}{factor named with cell names specifying the clusters of cells to be compared (one against all) (default=NULL). To compare two cell clusters against each other, simply pass a factor containing only two levels.}

\item{\code{clusterName}}{string Cluster name to access (default=NULL)}

\item{\code{dist}}{string 'pearson', 'spearman', 'euclidean', 'L2', 'JS' (default='pearson')}

\item{\code{persist}}{boolean Whether to save the clusters and community structure (default=TRUE)}

\item{\code{z.threshold}}{numeric Threshold of z-scores to filter, >=z.threshold are kept (default=2)}

\item{\code{n.cores}}{numeric Number of cores to use (default=1)}

\item{\code{min.set.size}}{integer Minimum threshold of sets to keep (default=5)}

\item{\code{verbose}}{boolean Whether to give verbose output (default=TRUE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
hierarchical clustering
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=400)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=20, type='PCA', center=FALSE, distance='cosine')
p2_object$getKnnClusters(method=walktrap.community,type='PCA',name='walktrap')
p2_object$getEmbedding(type='PCA', embeddingType = 'largeVis', M=30, perplexity=30, gamma=1/30, alpha=1)
p2_object$getDifferentialGenes(type='PCA', verbose=TRUE, clusterType='walktrap')
hdea <- p2_object$getHierarchicalDiffExpressionAspects(type='PCA', clusterName='walktrap', z.threshold=3)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-makeGeneKnnGraph"></a>}}
\if{latex}{\out{\hypertarget{method-makeGeneKnnGraph}{}}}
\subsection{Method \code{makeGeneKnnGraph()}}{
Calculates gene Knn network for gene similarity
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$makeGeneKnnGraph(
  nPcs = 100,
  scale = TRUE,
  center = TRUE,
  fastpath = TRUE,
  maxit = 1000,
  k = 30,
  n.cores = self$n.cores,
  verbose = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nPcs}}{integer Number of principal components (default=100). This is the parameter 'nv' in irlba::irlba(), the number of right singular vectors to estimate.}

\item{\code{center}}{boolean Whether to center the PCA (default=TRUE)}

\item{\code{fastpath}}{boolean Whether to try a (fast) C algorithm implementation if possible (default=TRUE). This parameter is equivalent to 'fastpath' in irlba::irlba().}

\item{\code{maxit}}{integer Maximum number of iterations (default=1000). This parameter is equivalent to 'maxit' in irlba::irlba().}

\item{\code{k}}{integer Number of k clusters for calculating k-NN on the resulting principal components (default=30).}

\item{\code{n.cores}}{numeric Number of cores to use (default=1)}

\item{\code{verbose}}{boolean Whether to give verbose output (default=TRUE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
graph with gene similarity
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeGeneKnnGraph(nPcs=50, k=20, center=TRUE)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getDensityClusters"></a>}}
\if{latex}{\out{\hypertarget{method-getDensityClusters}{}}}
\subsection{Method \code{getDensityClusters()}}{
Calculate density-based clusters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$getDensityClusters(
  type = "counts",
  embeddingType = NULL,
  name = "density",
  eps = 0.5,
  v = 0.7,
  s = 1,
  verbose = TRUE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{string Data type (default='counts'). Currently only 'counts' supported.}

\item{\code{embeddingType}}{The type of embedding used when calculating with `getEmbedding()` (default=NULL). Accepted values are: 'largeVis', 'tSNE', 'FR', 'UMAP', 'UMAP_graph'}

\item{\code{name}}{string Name fo the clustering (default='density').}

\item{\code{eps}}{numeric value of the eps parameter, fed into dbscan::dbscan(x=emb, eps=eps, ...)}

\item{\code{v}}{numeric The “value” to be used to complete the HSV color descriptions (default=0.7). Equivalent to the 'v' parameter in grDevices::rainbow().}

\item{\code{s}}{numeric The “saturation” to be used to complete the HSV color descriptions (default=1). Equivalent to the 's' parameter in grDevices::rainbow().}

\item{\code{verbose}}{boolean Whether to give verbose output (default=TRUE)}

\item{\code{...}}{additional parameters passed to dbscan::dbscan(emb, ...)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
density-based clusters
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{  
cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=50, type='PCA', center=TRUE, distance='cosine')
p2_object$getEmbedding(type='PCA', embeddingType = 'UMAP', M=20, perplexity=30, gamma=1/20)
p2_object$getDensityClusters(type='PCA')

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getDifferentialGenes"></a>}}
\if{latex}{\out{\hypertarget{method-getDifferentialGenes}{}}}
\subsection{Method \code{getDifferentialGenes()}}{
Determine differentially expressed genes, comparing each group against all others using Wilcoxon rank sum test
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$getDifferentialGenes(
  type = "counts",
  clusterType = NULL,
  groups = NULL,
  name = "customClustering",
  z.threshold = 3,
  upregulated.only = FALSE,
  verbose = FALSE,
  append.specificity.metrics = TRUE,
  append.auc = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{string Data type (default='counts'). Currently only 'counts' supported.}

\item{\code{clusterType}}{Optional cluster type to use as a group-defining factor (default=NULL)}

\item{\code{groups}}{factor named with cell names specifying the clusters of cells to be compared (one against all) (default=NULL). To compare two cell clusters against each other, simply pass a factor containing only two levels.}

\item{\code{name}}{string Slot to store the results in (default='customClustering')}

\item{\code{z.threshold}}{numeric Minimal absolute Z score (adjusted) to report (default=3)}

\item{\code{upregulated.only}}{boolean Whether to report only genes that are expressed significantly higher in each group (default=FALSE)}

\item{\code{verbose}}{boolean Whether to give verbose output (default=FALSE)}

\item{\code{append.specificity.metrics}}{boolean}

\item{\code{append.auc}}{boolean}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
list with each element of the list corresponding to a cell group in the provided/used factor (i.e. factor levels) 
    Each element of a list is a data frame listing the differentially epxressed genes (row names), with the following columns: 
    Z - adjusted Z score, with positive values indicating higher expression in a given group compare to the rest
    M - log2 fold change
    highest- a boolean flag indicating whether the expression of a given gene in a given vcell group was on average higher than in every other cell group
    fe - fraction of cells in a given group having non-zero expression level of a given gene
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=50, type='PCA', center=TRUE, distance='cosine')
p2_object$getKnnClusters(method=multilevel.community,type='PCA',name='multilevel')
p2_object$getEmbedding(type='PCA', embeddingType = 'UMAP', M=20, perplexity=30, gamma=1/20)
p2_object$getDifferentialGenes(type='PCA',verbose=TRUE,clusterType='multilevel')

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plotDiffGeneHeatmap"></a>}}
\if{latex}{\out{\hypertarget{method-plotDiffGeneHeatmap}{}}}
\subsection{Method \code{plotDiffGeneHeatmap()}}{
Plot heatmap of DE results
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$plotDiffGeneHeatmap(
  type = "counts",
  clusterType = NULL,
  groups = NULL,
  n.genes = 100,
  z.score = 2,
  gradient.range.quantile = 0.95,
  inner.clustering = FALSE,
  gradientPalette = NULL,
  v = 0.8,
  s = 1,
  box = TRUE,
  drawGroupNames = FALSE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{string Data type (default='counts'). Currently only 'counts' supported.}

\item{\code{clusterType}}{Optional cluster type to use as a group-defining factor (default=NULL)}

\item{\code{groups}}{factor named with cell names specifying the clusters of cells to be compared (one against all) (default=NULL). To compare two cell clusters against each other, simply pass a factor containing only two levels.}

\item{\code{n.genes}}{integer Number of genes to plot (default=100)}

\item{\code{z.score}}{numeric Threshold of z-scores to filter; only greater than or equal to this value are kept (default=2)}

\item{\code{gradient.range.quantile}}{numeric (default=0.95)}

\item{\code{inner.clustering}}{boolean Whether to cluster cells within each cluster (default=FALSE)}

\item{\code{gradientPalette}}{palette of colors to use (default=NULL). If NULL, uses 'colorRampPalette(c('gray90','red'), space = "Lab")(1024)'}

\item{\code{v}}{numeric The “value” to be used to complete the HSV color descriptions (default=0.7). Equivalent to the 'v' parameter in grDevices::rainbow().}

\item{\code{s}}{numeric The “saturation” to be used to complete the HSV color descriptions (default=1). Equivalent to the 's' parameter in grDevices::rainbow().}

\item{\code{box}}{boolean Whether to draw a box around the current plot in the given color and linetype (default=TRUE)}

\item{\code{drawGroupNames}}{boolean Whether to draw group names (default=FALSE)}

\item{\code{...}}{additional parameters passed to internal function used for heatmap plotting, my.heatmap2()}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{

}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getRefinedLibSizes"></a>}}
\if{latex}{\out{\hypertarget{method-getRefinedLibSizes}{}}}
\subsection{Method \code{getRefinedLibSizes()}}{
Recalculate library sizes using robust regression within clusters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$getRefinedLibSizes(clusterType = NULL, groups = NULL, type = "counts")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{clusterType}}{Optional cluster type to use as a group-defining factor (default=NULL)}

\item{\code{groups}}{factor named with cell names specifying the clusters of cells to be compared (one against all) (default=NULL). To compare two cell clusters against each other, simply pass a factor containing only two levels.}

\item{\code{type}}{string Data type (default='counts'). Currently only 'counts' supported.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{

}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plotGeneHeatmap"></a>}}
\if{latex}{\out{\hypertarget{method-plotGeneHeatmap}{}}}
\subsection{Method \code{plotGeneHeatmap()}}{
Plot heatmap for a given set of genes
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$plotGeneHeatmap(
  genes,
  type = "counts",
  clusterType = NULL,
  groups = NULL,
  gradient.range.quantile = 0.95,
  cluster.genes = FALSE,
  inner.clustering = FALSE,
  gradientPalette = NULL,
  v = 0.8,
  s = 1,
  box = TRUE,
  drawGroupNames = FALSE,
  useRaster = TRUE,
  smooth.span = max(1, round(nrow(self$counts)/1024)),
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{genes}}{}

\item{\code{type}}{string Data type (default='counts'). Currently only 'counts' supported.}

\item{\code{clusterType}}{Optional cluster type to use as a group-defining factor (default=NULL)}

\item{\code{groups}}{factor named with cell names specifying the clusters of cells to be compared (one against all) (default=NULL). To compare two cell clusters against each other, simply pass a factor containing only two levels.}

\item{\code{cluster.genes}}{boolean (default=FALSE)}

\item{\code{inner.clustering}}{boolean Whether to cluster cells within each cluster (default=FALSE)}

\item{\code{gradientPalette}}{palette of colors to use (default=NULL). If NULL, uses 'colorRampPalette(c('gray90','red'), space = "Lab")(1024)'}

\item{\code{v}}{numeric The “value” to be used to complete the HSV color descriptions (default=0.7). Equivalent to the 'v' parameter in grDevices::rainbow().}

\item{\code{s}}{numeric The “saturation” to be used to complete the HSV color descriptions (default=1). Equivalent to the 's' parameter in grDevices::rainbow().}

\item{\code{box}}{boolean Whether to draw a box around the current plot in the given color and linetype (default=TRUE)}

\item{\code{drawGroupNames}}{boolean Whether to draw group names (default=FALSE)}

\item{\code{useRaster}}{boolean If TRUE a bitmap raster is used to plot the image instead of polygons (default=TRUE). The grid must be regular in that case, otherwise an error is raised. For more information, see graphics::image().}

\item{\code{smooth.span}}{(default=max(1,round(nrow(self$counts)/1024)))}

\item{\code{...}}{additional parameters passed to internal function used for heatmap plotting, my.heatmap2()}

\item{\code{grandient.range.quantile}}{(default=0.95)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{

}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=50, type='PCA', center=TRUE, distance='cosine')
p2_object$getKnnClusters(method=multilevel.community,type='PCA',name='multilevel')
p2_object$getEmbedding(type='PCA', embeddingType = 'UMAP', M=20, perplexity=30, gamma=1/20)
p2_object$getDifferentialGenes(type='PCA',verbose=TRUE,clusterType='multilevel')
de <- p2_object$diffgenes$PCA[[1]][['2']]
p2_object$plotGeneHeatmap(genes=rownames(de)[1:15], groups=p2_object$clusters$PCA[[1]], cluster.genes=TRUE)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plotEmbedding"></a>}}
\if{latex}{\out{\hypertarget{method-plotEmbedding}{}}}
\subsection{Method \code{plotEmbedding()}}{
Show embedding
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$plotEmbedding(
  type = NULL,
  embeddingType = NULL,
  clusterType = NULL,
  groups = NULL,
  colors = NULL,
  gene = NULL,
  plot.theme = ggplot2::theme_bw(),
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{(default=NULL)}

\item{\code{embeddingType}}{(default=NULL)}

\item{\code{clusterType}}{(default=NULL)}

\item{\code{groups}}{(default=NULL)}

\item{\code{colors}}{(default=NULL)}

\item{\code{gene}}{(default=NULL)}

\item{\code{plot.theme}}{(default=ggplot2::theme_bw())}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{

}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=50, type='PCA', center=TRUE, distance='cosine')
p2_object$getKnnClusters(method=multilevel.community,type='PCA',name='multilevel')
p2_object$getEmbedding(type='PCA', embeddingType = 'UMAP', M=20, perplexity=30, gamma=1/20)
library(ggplot2)
p2_object$plotEmbedding(type='PCA', show.legend=FALSE, mark.groups=TRUE, min.cluster.size=50, shuffle.colors=FALSE, font.size=1, alpha=0.1, 
  title='clusters (UMAP)', plot.theme=theme(plot.title = element_text(hjust = 0.5)))
}

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getOdGenes"></a>}}
\if{latex}{\out{\hypertarget{method-getOdGenes}{}}}
\subsection{Method \code{getOdGenes()}}{
Get overdispersed genes
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$getOdGenes(
  n.odgenes = NULL,
  alpha = 0.05,
  use.unadjusted.pvals = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n.odgenes}}{character vector Overdispersed genes to retrieve (default=NULL)}

\item{\code{alpha}}{numeric The Type I error probability or the significance level (default=5e-2). This is the criterion used to measure statistical significance, i.e. if the p-value < alpha, then it is statistically significant.}

\item{\code{use.unadjusted.pvals}}{boolean Whether to use Benjamini-Hochberg adjusted p-values (default=FALSE).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
vector of overdispersed genes
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=50, type='PCA', center=TRUE, distance='cosine')
p2_object$getKnnClusters(method=infomap.community, type='PCA')
p2_object$getEmbedding(type='PCA', M=20, perplexity=30, gamma=1/20)
p2_object$getDifferentialGenes(type='PCA',verbose=TRUE)
odGenes <- p2_object$getOdGenes(use.unadjusted.pvals=FALSE)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getNormalizedExpressionMatrix"></a>}}
\if{latex}{\out{\hypertarget{method-getNormalizedExpressionMatrix}{}}}
\subsection{Method \code{getNormalizedExpressionMatrix()}}{
Return variance-normalized matrix for specified genes or a number of OD genes
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$getNormalizedExpressionMatrix(genes = NULL, n.odgenes = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{genes}}{vector of gene names to explicitly return (default=NULL)}

\item{\code{n.odgenes}}{overdispersed genes to retrieve (default=NULL). If NULL, all significant overdispersed genes are used. If 'genes' is not NULL, this parameter is ignored.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
cell by gene matrix
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$getNormalizedExpressionMatrix()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-calculatePcaReduction"></a>}}
\if{latex}{\out{\hypertarget{method-calculatePcaReduction}{}}}
\subsection{Method \code{calculatePcaReduction()}}{
Calculate PCA reduction of the data
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$calculatePcaReduction(
  nPcs = 20,
  type = "counts",
  name = "PCA",
  use.odgenes = TRUE,
  n.odgenes = NULL,
  odgenes = NULL,
  center = TRUE,
  cells = NULL,
  fastpath = TRUE,
  maxit = 100,
  verbose = TRUE,
  var.scale = (type == "counts"),
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nPcs}}{Number of PCs (default=20)}

\item{\code{type}}{Dataset view to reduce (counts by default, but can specify a name of an existing reduction) (default='counts')}

\item{\code{name}}{Name for the PCA reduction to be created (default='PCA')}

\item{\code{use.odgenes}}{boolean Whether pre-calculated set of overdispersed genes should be used (default=TRUE)}

\item{\code{n.odgenes}}{Whether a certain number of top overdispersed genes should be used (default=NULL)}

\item{\code{odgenes}}{Explicitly specify a set of overdispersed genes to use for the reduction (default=NULL)}

\item{\code{center}}{boolean Whether data should be centered prior to PCA (default=TRUE)}

\item{\code{cells}}{optional subset of cells on which PCA should be run (default=NULL)}

\item{\code{fastpath}}{boolean Use C implementation for speedup (default=TRUE)}

\item{\code{verbose}}{boolean Whether to give verbose output (default=TRUE)}

\item{\code{...}}{additional arguments forwarded to irlba::irlba}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisible PCA result (the reduction itself is saved in self$reductions[[name]])"
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=600)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts, log.scale=FALSE, min.cells.per.gene=30, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=15)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=2e3)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-expandOdGenes"></a>}}
\if{latex}{\out{\hypertarget{method-expandOdGenes}{}}}
\subsection{Method \code{expandOdGenes()}}{
Reset odgenes to be a superset of the standard odgene selection (guided by n.odgenes or alpha), 
    and a set of recursively determined odgenes based on a given group (or a cluster info)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$expandOdGenes(
  type = "counts",
  clusterType = NULL,
  groups = NULL,
  min.group.size = 30,
  od.alpha = 0.1,
  use.odgenes = FALSE,
  n.odgenes = NULL,
  odgenes = NULL,
  n.odgene.multiplier = 1,
  gam.k = 10,
  verbose = FALSE,
  n.cores = self$n.cores,
  min.odgenes = 10,
  max.odgenes = Inf,
  take.top.odgenes = TRUE,
  recursive = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{string Data type (default='counts'). Currently only 'counts' supported.}

\item{\code{clusterType}}{Optional cluster type to use as a group-defining factor (default=NULL)}

\item{\code{groups}}{factor named with cell names specifying the clusters of cells to be compared (one against all) (default=NULL). To compare two cell clusters against each other, simply pass a factor containing only two levels.}

\item{\code{min.group.size}}{integer (default=30)}

\item{\code{od.alpha}}{numeric (default=1e-1)}

\item{\code{use.odgenes}}{boolean (default=FALSE)}

\item{\code{n.odgenes}}{(default=NULL)}

\item{\code{odgenes}}{(default=NULL)}

\item{\code{n.odgene.multiplier}}{numeric (default=1)}

\item{\code{gam.k}}{integer The k used for the generalized additive model 'v ~ s(m, k =gam.k)' (default=10). If gam.k<2, linear regression is used 'lm(v ~ m)'.}

\item{\code{verbose}}{boolean Whether to give verbose output (default=TRUE)}

\item{\code{n.cores}}{numeric Number of cores to use (default=1)}

\item{\code{min.odgenes}}{integer (default=10)}

\item{\code{max.odgenes}}{integer (default=Inf)}

\item{\code{take.top.odgenes}}{boolean (default=TRUE)}

\item{\code{recursive}}{boolean (default=TRUE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
List of overdispersed genes
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{cm <- readRDS(system.file("extdata", "sample_BM1.rds", package="pagoda2"))
counts <- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=50, type='PCA', center=TRUE, distance='cosine')
p2_object$getKnnClusters(method=infomap.community, type='PCA')
p2_object$getEmbedding(type='PCA', M=20, perplexity=30, gamma=1/20)
p2_object$getDifferentialGenes(type='PCA',verbose=TRUE)
p2_object$expandOdGenes(type='PCA')

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-localPcaKnn"></a>}}
\if{latex}{\out{\hypertarget{method-localPcaKnn}{}}}
\subsection{Method \code{localPcaKnn()}}{
localPcaKnn description
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$localPcaKnn(
  nPcs = 5,
  type = "counts",
  clusterType = NULL,
  groups = NULL,
  k = 30,
  b = 1,
  a = 1,
  min.group.size = 30,
  name = "localPCA",
  baseReduction = "PCA",
  od.alpha = 0.1,
  n.odgenes = NULL,
  gam.k = 10,
  verbose = FALSE,
  n.cores = self$n.cores,
  min.odgenes = 5,
  take.top.odgenes = FALSE,
  recursive = TRUE,
  euclidean = FALSE,
  perplexity = k,
  return.pca = FALSE,
  skip.pca = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nPcs}}{integer (default=5)}

\item{\code{type}}{string Data type (default='counts'). Currently only 'counts' supported.}

\item{\code{clusterType}}{Optional cluster type to use as a group-defining factor (default=NULL)}

\item{\code{groups}}{factor named with cell names specifying the clusters of cells to be compared (one against all) (default=NULL). To compare two cell clusters against each other, simply pass a factor containing only two levels.}

\item{\code{k}}{integer (default=30)}

\item{\code{b}}{numeric (default=1)}

\item{\code{a}}{numeric (default=1)}

\item{\code{min.group.size}}{integer (default=30)}

\item{\code{name}}{string (default='localPCA')}

\item{\code{baseReduction}}{string (default='PCA')}

\item{\code{od.alpha}}{numeric (default=1e-1)}

\item{\code{n.odgenes}}{(default=NULL)}

\item{\code{gam.k}}{integer The k used for the generalized additive model 'v ~ s(m, k =gam.k)' (default=10). If gam.k<2, linear regression is used 'lm(v ~ m)'.}

\item{\code{verbose}}{boolean Whether to give verbose output (default=TRUE)}

\item{\code{n.cores}}{numeric Number of cores to use (default=1)}

\item{\code{min.odgenes}}{integer (default=5)}

\item{\code{take.top.odgenes}}{boolean (default=FALSE)}

\item{\code{recursive}}{boolean (default=FALSE)}

\item{\code{euclidean}}{boolean (default=FALSE)}

\item{\code{perplexity}}{integer (default=k)}

\item{\code{return.pca}}{boolean (default=FALSE)}

\item{\code{skip.pca}}{boolean (default=FALSE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{

}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-testPathwayOverdispersion"></a>}}
\if{latex}{\out{\hypertarget{method-testPathwayOverdispersion}{}}}
\subsection{Method \code{testPathwayOverdispersion()}}{
Test pathway overdispersion. Note: this is a compressed version of the PAGODA1 approach.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$testPathwayOverdispersion(
  setenv,
  type = "counts",
  max.pathway.size = 1000,
  min.pathway.size = 10,
  n.randomizations = 5,
  verbose = FALSE,
  score.alpha = 0.05,
  plot = FALSE,
  cells = NULL,
  adjusted.pvalues = TRUE,
  z.score = qnorm(0.05/2, lower.tail = FALSE),
  use.oe.scale = FALSE,
  return.table = FALSE,
  name = "pathwayPCA",
  correlation.distance.threshold = 0.2,
  loading.distance.threshold = 0.01,
  top.aspects = Inf,
  recalculate.pca = FALSE,
  save.pca = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{setenv}}{specific environment for GO pathway analysis}

\item{\code{type}}{string Data type (default='counts'). Currently only 'counts' supported.}

\item{\code{max.pathway.size}}{numeric (default=1e3)}

\item{\code{min.pathway.size}}{numeric (default=10)}

\item{\code{n.randomizations}}{integer (default=5)}

\item{\code{verbose}}{boolean Whether to give verbose output (default=TRUE)}

\item{\code{score.alpha}}{numeric (default=0.05)}

\item{\code{plot}}{boolean Whether to output the plot (default=FALSE)}

\item{\code{cells}}{(default=NULL)}

\item{\code{adjusted.pvalues}}{boolean (default=TRUE)}

\item{\code{z.score}}{numeric (default=qnorm(0.05/2, lower.tail = FALSE))}

\item{\code{use.oe.scale}}{boolean (default=FALSE)}

\item{\code{return.table}}{boolean (default=FALSE)}

\item{\code{name}}{string (default='pathwayPCA')}

\item{\code{loading.distance.threshold}}{numeric (default=0.2)}

\item{\code{top.aspects}}{(default=Inf)}

\item{\code{recalculate.pca}}{boolean (default=FALSE)}

\item{\code{save.pca}}{boolean (default=TRUE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{

}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getEmbedding"></a>}}
\if{latex}{\out{\hypertarget{method-getEmbedding}{}}}
\subsection{Method \code{getEmbedding()}}{
Return embedding
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$getEmbedding(
  type = "counts",
  embeddingType = "largeVis",
  name = NULL,
  dims = 2,
  M = 1,
  gamma = 1/M,
  perplexity = 50,
  verbose = TRUE,
  sgd_batches = NULL,
  diffusion.steps = 0,
  diffusion.power = 0.5,
  distance = "pearson",
  n.cores = self$n.cores,
  n.sgd.cores = n.cores,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{string Data type (default='counts'). Currently only 'counts' supported.}

\item{\code{embeddingType}}{string 'largeVis', 'tSNE', 'FR', 'UMAP', 'UMAP_graph' (default='largeVis')}

\item{\code{name}}{string (default=NULL)}

\item{\code{dims}}{integer (default=2)}

\item{\code{M}}{integer}

\item{\code{gamma}}{integer}

\item{\code{verbose}}{boolean (default=TRUE)}

\item{\code{n.cores}}{numeric Number of cores to use (default=1)}

\item{\code{...}}{}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{

}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{cm <- readRDS(file.path(find.package('pagoda2'),'extdata','sample_BM1.rds'))
counts <- gene.vs.molecule.cell.filter(cm,min.cell.size=500)
rownames(counts) <- make.unique(rownames(counts))
p2_object <- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
p2_object$adjustVariance(plot=TRUE, gam.k=10)
p2_object$calculatePcaReduction(nPcs=50, n.odgenes=3e3)
p2_object$makeKnnGraph(k=40, type='PCA', center=TRUE, distance='cosine')
p2_object$getKnnClusters(method=infomap.community, type='PCA')
p2_object$getEmbedding(type='PCA', embeddingType = 'UMAP', M=30, perplexity=30, gamma=1/30, alpha=1)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pagoda2$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
